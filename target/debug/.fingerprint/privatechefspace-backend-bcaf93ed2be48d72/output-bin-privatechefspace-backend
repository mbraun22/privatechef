{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/menu.rs","byte_start":466,"byte_end":552,"line_start":18,"line_end":21,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT id FROM chefs WHERE user_id = $1\",","highlight_start":1,"highlight_end":51},{"text":"        user_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:18:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id FROM chefs WHERE user_id = $1\",\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/menu.rs","byte_start":1569,"byte_end":1655,"line_start":57,"line_end":60,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT id FROM chefs WHERE user_id = $1\",","highlight_start":1,"highlight_end":51},{"text":"        user_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:57:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id FROM chefs WHERE user_id = $1\",\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/menu.rs","byte_start":2273,"byte_end":2454,"line_start":84,"line_end":90,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        *menu_id","highlight_start":1,"highlight_end":17},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:84:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id,\n\u001b[1m\u001b[94m89\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         *menu_id\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/menu.rs","byte_start":3680,"byte_end":3861,"line_start":129,"line_end":135,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        *menu_id","highlight_start":1,"highlight_end":17},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:129:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m130\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m132\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m133\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id,\n\u001b[1m\u001b[94m134\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         *menu_id\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/menu_item.rs","byte_start":513,"byte_end":694,"line_start":19,"line_end":25,"column_start":17,"column_end":6,"is_primary":false,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        *menu_id","highlight_start":1,"highlight_end":17},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu_item.rs:19:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id,\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         *menu_id\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/menu_item.rs","byte_start":2164,"byte_end":2344,"line_start":77,"line_end":83,"column_start":17,"column_end":6,"is_primary":false,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        menu_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu_item.rs:77:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id,\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         menu_id\n\u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/menu_item.rs","byte_start":3585,"byte_end":3765,"line_start":125,"line_end":131,"column_start":17,"column_end":6,"is_primary":false,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        menu_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu_item.rs:125:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m126\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m127\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m128\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id,\n\u001b[1m\u001b[94m130\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         menu_id\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/booking.rs","byte_start":534,"byte_end":661,"line_start":18,"line_end":21,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT hourly_rate, minimum_hours FROM chefs WHERE id = $1 AND is_active = true\",","highlight_start":1,"highlight_end":91},{"text":"        *chef_id","highlight_start":1,"highlight_end":17},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:18:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT hourly_rate, minimum_hours FROM chefs WHERE id = $1 AND is_active = true\",\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         *chef_id\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/booking.rs","byte_start":1208,"byte_end":1480,"line_start":33,"line_end":44,"column_start":20,"column_end":6,"is_primary":false,"text":[{"text":"    let conflict = sqlx::query!(","highlight_start":20,"highlight_end":33},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        SELECT id FROM bookings","highlight_start":1,"highlight_end":32},{"text":"        WHERE chef_id = $1","highlight_start":1,"highlight_end":27},{"text":"        AND event_date = $2","highlight_start":1,"highlight_end":28},{"text":"        AND event_time = $3","highlight_start":1,"highlight_end":28},{"text":"        AND status IN ('pending', 'confirmed')","highlight_start":1,"highlight_end":47},{"text":"        \"#,","highlight_start":1,"highlight_end":12},{"text":"        *chef_id,","highlight_start":1,"highlight_end":18},{"text":"        data.event_date,","highlight_start":1,"highlight_end":25},{"text":"        data.event_time","highlight_start":1,"highlight_end":24},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:33:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let conflict = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         SELECT id FROM bookings\n\u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         WHERE chef_id = $1\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         data.event_time\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/booking.rs","byte_start":3230,"byte_end":3519,"line_start":96,"line_end":107,"column_start":20,"column_end":6,"is_primary":false,"text":[{"text":"    let bookings = sqlx::query!(","highlight_start":20,"highlight_end":33},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        SELECT event_date, event_time, duration_hours","highlight_start":1,"highlight_end":54},{"text":"        FROM bookings","highlight_start":1,"highlight_end":22},{"text":"        WHERE chef_id = $1","highlight_start":1,"highlight_end":27},{"text":"        AND event_date BETWEEN $2 AND $3","highlight_start":1,"highlight_end":41},{"text":"        AND status IN ('pending', 'confirmed')","highlight_start":1,"highlight_end":47},{"text":"        \"#,","highlight_start":1,"highlight_end":12},{"text":"        *chef_id,","highlight_start":1,"highlight_end":18},{"text":"        start_date,","highlight_start":1,"highlight_end":20},{"text":"        end_date","highlight_start":1,"highlight_end":17},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:96:20\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bookings = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n \u001b[1m\u001b[94m97\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"\n \u001b[1m\u001b[94m98\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         SELECT event_date, event_time, duration_hours\n \u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         FROM bookings\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         end_date\n\u001b[1m\u001b[94m107\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/booking.rs","byte_start":4957,"byte_end":5073,"line_start":156,"line_end":160,"column_start":17,"column_end":6,"is_primary":false,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT id FROM chefs WHERE id = $1 AND user_id = $2\",","highlight_start":1,"highlight_end":63},{"text":"        *chef_id,","highlight_start":1,"highlight_end":18},{"text":"        user_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:156:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id FROM chefs WHERE id = $1 AND user_id = $2\",\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         *chef_id,\n\u001b[1m\u001b[94m159\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"error returned from database: database \"privatechefspace\" does not exist","code":null,"level":"error","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/booking.rs","byte_start":5727,"byte_end":5914,"line_start":184,"line_end":190,"column_start":17,"column_end":6,"is_primary":false,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN bookings b ON b.chef_id = c.id","highlight_start":1,"highlight_end":51},{"text":"         WHERE c.user_id = $1 AND b.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        *booking_id","highlight_start":1,"highlight_end":20},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: error returned from database: database \"privatechefspace\" does not exist\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:184:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m184\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m186\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN bookings b ON b.chef_id = c.id\n\u001b[1m\u001b[94m187\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND b.id = $2\",\n\u001b[1m\u001b[94m188\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id,\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         *booking_id\n\u001b[1m\u001b[94m190\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Responder`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/auth.rs","byte_start":35,"byte_end":44,"line_start":1,"line_end":1,"column_start":36,"column_end":45,"is_primary":true,"text":[{"text":"use actix_web::{web, HttpResponse, Responder};","highlight_start":36,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/handlers/auth.rs","byte_start":33,"byte_end":44,"line_start":1,"line_end":1,"column_start":34,"column_end":45,"is_primary":true,"text":[{"text":"use actix_web::{web, HttpResponse, Responder};","highlight_start":34,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `Responder`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/auth.rs:1:36\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use actix_web::{web, HttpResponse, Responder};\n  \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `auth::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/mod.rs","byte_start":87,"byte_end":94,"line_start":7,"line_end":7,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"pub use auth::*;","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/handlers/mod.rs","byte_start":79,"byte_end":96,"line_start":7,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use auth::*;","highlight_start":1,"highlight_end":17},{"text":"pub use chef::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `auth::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/mod.rs:7:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use auth::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `chef::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/mod.rs","byte_start":104,"byte_end":111,"line_start":8,"line_end":8,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"pub use chef::*;","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/handlers/mod.rs","byte_start":96,"byte_end":113,"line_start":8,"line_end":9,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use chef::*;","highlight_start":1,"highlight_end":17},{"text":"pub use menu::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `chef::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/mod.rs:8:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use chef::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `menu::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/mod.rs","byte_start":121,"byte_end":128,"line_start":9,"line_end":9,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"pub use menu::*;","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/handlers/mod.rs","byte_start":113,"byte_end":130,"line_start":9,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use menu::*;","highlight_start":1,"highlight_end":17},{"text":"pub use menu_item::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `menu::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/mod.rs:9:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use menu::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `menu_item::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/mod.rs","byte_start":138,"byte_end":150,"line_start":10,"line_end":10,"column_start":9,"column_end":21,"is_primary":true,"text":[{"text":"pub use menu_item::*;","highlight_start":9,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/handlers/mod.rs","byte_start":130,"byte_end":152,"line_start":10,"line_end":11,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use menu_item::*;","highlight_start":1,"highlight_end":22},{"text":"pub use booking::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `menu_item::*`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/mod.rs:10:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use menu_item::*;\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `booking::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/mod.rs","byte_start":160,"byte_end":170,"line_start":11,"line_end":11,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"pub use booking::*;","highlight_start":9,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/handlers/mod.rs","byte_start":152,"byte_end":172,"line_start":11,"line_end":12,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use booking::*;","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `booking::*`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/mod.rs:11:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use booking::*;\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `auth::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/middleware/mod.rs","byte_start":37,"byte_end":44,"line_start":4,"line_end":4,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"pub use auth::*;","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/middleware/mod.rs","byte_start":29,"byte_end":46,"line_start":4,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use auth::*;","highlight_start":1,"highlight_end":17},{"text":"pub use cors::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `auth::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/middleware/mod.rs:4:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use auth::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `cors::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/middleware/mod.rs","byte_start":54,"byte_end":61,"line_start":5,"line_end":5,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"pub use cors::*;","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/middleware/mod.rs","byte_start":46,"byte_end":63,"line_start":5,"line_end":6,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use cors::*;","highlight_start":1,"highlight_end":17},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `cors::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/middleware/mod.rs:5:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use cors::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/cache/session.rs","byte_start":685,"byte_end":688,"line_start":22,"line_end":22,"column_start":33,"column_end":36,"is_primary":true,"text":[{"text":"        conn.set_ex(key, value, ttl).await?;","highlight_start":33,"highlight_end":36}],"label":"expected `u64`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/cache/session.rs","byte_start":666,"byte_end":672,"line_start":22,"line_end":22,"column_start":14,"column_end":20,"is_primary":false,"text":[{"text":"        conn.set_ex(key, value, ttl).await?;","highlight_start":14,"highlight_end":20}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.24.0/src/commands/mod.rs","byte_start":3434,"byte_end":3440,"line_start":83,"line_end":83,"column_start":8,"column_end":14,"is_primary":true,"text":[{"text":"    fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, seconds: u64) {","highlight_start":8,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `usize` to a `u64` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/cache/session.rs","byte_start":688,"byte_end":688,"line_start":22,"line_end":22,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        conn.set_ex(key, value, ttl).await?;","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/cache/session.rs:22:33\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         conn.set_ex(key, value, ttl).await?;\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m------\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `u64`, found `usize`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.24.0/src/commands/mod.rs:83:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, seconds: u64) {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert a `usize` to a `u64` and panic if the converted value doesn't fit\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        conn.set_ex(key, value, ttl\u001b[92m.try_into().unwrap()\u001b[0m).await?;\n   \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[92m++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/cache/session.rs","byte_start":506,"byte_end":597,"line_start":20,"line_end":20,"column_start":5,"column_end":96,"is_primary":true,"text":[{"text":"    pub async fn set_session(&self, key: &str, value: &str, ttl: usize) -> Result<(), AppError> {","highlight_start":5,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"src/cache/session.rs","byte_start":666,"byte_end":672,"line_start":22,"line_end":22,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"        conn.set_ex(key, value, ttl).await?;","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/cache/session.rs","byte_start":672,"byte_end":672,"line_start":22,"line_end":22,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        conn.set_ex(key, value, ttl).await?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"::<_, _, ()>","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/cache/session.rs:20:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn set_session(&self, key: &str, value: &str, ttl: usize) -> Result<(), AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/cache/session.rs:22:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         conn.set_ex(key, value, ttl).await?;\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        conn.set_ex\u001b[92m::<_, _, ()>\u001b[0m(key, value, ttl).await?;\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":468,"byte_end":472,"line_start":15,"line_end":15,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"    let existing = sqlx::query_as::<_, Chef>(","highlight_start":40,"highlight_end":44}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:15:40\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let existing = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":468,"byte_end":472,"line_start":15,"line_end":15,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"    let existing = sqlx::query_as::<_, Chef>(","highlight_start":40,"highlight_end":44}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:15:40\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let existing = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::chef::Chef, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":448,"byte_end":555,"line_start":15,"line_end":19,"column_start":20,"column_end":6,"is_primary":false,"text":[{"text":"    let existing = sqlx::query_as::<_, Chef>(","highlight_start":20,"highlight_end":46},{"text":"        \"SELECT * FROM chefs WHERE user_id = $1\"","highlight_start":1,"highlight_end":49},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(*user_id)","highlight_start":1,"highlight_end":20},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":555,"byte_end":569,"line_start":19,"line_end":19,"column_start":6,"column_end":20,"is_primary":true,"text":[{"text":"    .fetch_optional(pool.get_ref())","highlight_start":6,"highlight_end":20}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/chef.rs","byte_start":186,"byte_end":201,"line_start":8,"line_end":8,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Chef {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::chef::Chef: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::chef::Chef: FromRow<'r, PgRow>`\n`Decimal: Type<Postgres>`\nwhich is required by `models::chef::Chef: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::chef::Chef, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:19:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let existing = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ____________________-\u001b[0m\n \u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \"SELECT * FROM chefs WHERE user_id = $1\"\n \u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     )\n \u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(*user_id)\n \u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_optional(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/chef.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::chef::Chef: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: sqlx::Decode<'_, Postgres>`\n            which is required by `models::chef::Chef: FromRow<'r, PgRow>`\n            `Decimal: Type<Postgres>`\n            which is required by `models::chef::Chef: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":607,"byte_end":615,"line_start":22,"line_end":22,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"    if existing.is_some() {","highlight_start":8,"highlight_end":16}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":437,"byte_end":445,"line_start":15,"line_end":15,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    let existing = sqlx::query_as::<_, Chef>(","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving `existing` an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/chef.rs","byte_start":445,"byte_end":445,"line_start":15,"line_end":15,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    let existing = sqlx::query_as::<_, Chef>(","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:15:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let existing = sqlx::query_as::<_, Chef>(\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     if existing.is_some() {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving `existing` an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let existing\u001b[92m: /* Type */\u001b[0m = sqlx::query_as::<_, Chef>(\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":844,"byte_end":848,"line_start":29,"line_end":29,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":36,"highlight_end":40}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:29:36\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":844,"byte_end":848,"line_start":29,"line_end":29,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":36,"highlight_end":40}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:29:36\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":1572,"byte_end":1588,"line_start":51,"line_end":51,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"    .bind(&data.hourly_rate)","highlight_start":12,"highlight_end":28}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":1566,"byte_end":1570,"line_start":51,"line_end":51,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&data.hourly_rate)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 41 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Encode<'_, Postgres>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:51:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&data.hourly_rate)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, Postgres>` is not implemented for `Decimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n             `&'a str` implements `Encode<'a, sqlx::Any>`\n             `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n             `&T` implements `Encode<'q, DB>`\n             `&[T]` implements `Encode<'q, Postgres>`\n             `&[u8]` implements `Encode<'_, Postgres>`\n             `&str` implements `Encode<'_, Postgres>`\n             `Box<[u8]>` implements `Encode<'_, Postgres>`\n             `Box<str>` implements `Encode<'_, Postgres>`\n           and 41 others\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":1572,"byte_end":1588,"line_start":51,"line_end":51,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"    .bind(&data.hourly_rate)","highlight_start":12,"highlight_end":28}],"label":"the trait `Type<Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":1566,"byte_end":1570,"line_start":51,"line_end":51,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&data.hourly_rate)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<Postgres>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:51:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&data.hourly_rate)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `Decimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n             `&T` implements `Type<DB>`\n             `()` implements `Type<Postgres>`\n             `(T1, T2)` implements `Type<Postgres>`\n             `(T1, T2, T3)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n           and 51 others\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::chef::Chef, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":824,"byte_end":1686,"line_start":29,"line_end":55,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":16,"highlight_end":42},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        INSERT INTO chefs (","highlight_start":1,"highlight_end":28},{"text":"            user_id, business_name, chef_name, bio, cuisine_types, location,","highlight_start":1,"highlight_end":77},{"text":"            phone, email, website, profile_image_url, cover_image_url,","highlight_start":1,"highlight_end":71},{"text":"            hourly_rate, minimum_hours, travel_radius, slug, created_at, updated_at","highlight_start":1,"highlight_end":84},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, NOW(), NOW())","highlight_start":1,"highlight_end":96},{"text":"        RETURNING *","highlight_start":1,"highlight_end":20},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(*user_id)","highlight_start":1,"highlight_end":20},{"text":"    .bind(&data.business_name)","highlight_start":1,"highlight_end":31},{"text":"    .bind(&data.chef_name)","highlight_start":1,"highlight_end":27},{"text":"    .bind(&data.bio)","highlight_start":1,"highlight_end":21},{"text":"    .bind(&data.cuisine_types)","highlight_start":1,"highlight_end":31},{"text":"    .bind(&data.location)","highlight_start":1,"highlight_end":26},{"text":"    .bind(&data.phone)","highlight_start":1,"highlight_end":23},{"text":"    .bind(&data.email)","highlight_start":1,"highlight_end":23},{"text":"    .bind(&data.website)","highlight_start":1,"highlight_end":25},{"text":"    .bind(&data.profile_image_url)","highlight_start":1,"highlight_end":35},{"text":"    .bind(&data.cover_image_url)","highlight_start":1,"highlight_end":33},{"text":"    .bind(&data.hourly_rate)","highlight_start":1,"highlight_end":29},{"text":"    .bind(data.minimum_hours.unwrap_or(2))","highlight_start":1,"highlight_end":43},{"text":"    .bind(&data.travel_radius)","highlight_start":1,"highlight_end":31},{"text":"    .bind(&slug)","highlight_start":1,"highlight_end":17},{"text":"    .fetch_one(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":1686,"byte_end":1695,"line_start":55,"line_end":55,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(pool.get_ref())","highlight_start":6,"highlight_end":15}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/chef.rs","byte_start":186,"byte_end":201,"line_start":8,"line_end":8,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Chef {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::chef::Chef: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::chef::Chef: FromRow<'r, PgRow>`\n`Decimal: Type<Postgres>`\nwhich is required by `models::chef::Chef: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::chef::Chef, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:55:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ________________-\u001b[0m\n \u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n \u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         INSERT INTO chefs (\n \u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             user_id, business_name, chef_name, bio, cuisine_types, location,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&slug)\n \u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/chef.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::chef::Chef: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: sqlx::Decode<'_, Postgres>`\n            which is required by `models::chef::Chef: FromRow<'r, PgRow>`\n            `Decimal: Type<Postgres>`\n            which is required by `models::chef::Chef: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":221,"byte_end":382,"line_start":9,"line_end":13,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn create_chef_profile(","highlight_start":1,"highlight_end":34},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":"    user_id: web::Path<Uuid>,","highlight_start":1,"highlight_end":30},{"text":"    data: web::Json<CreateChef>,","highlight_start":1,"highlight_end":33},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/chef.rs","byte_start":1762,"byte_end":1766,"line_start":58,"line_end":58,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Created().json(chef))","highlight_start":37,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/chef.rs","byte_start":821,"byte_end":821,"line_start":29,"line_end":29,"column_start":13,"column_end":13,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":13,"highlight_end":13}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:9:1\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn create_chef_profile(\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     user_id: web::Path<Uuid>,\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     data: web::Json<CreateChef>,\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:58:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Created().json(chef))\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let chef\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Chef>(\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":1935,"byte_end":1939,"line_start":65,"line_end":65,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":36,"highlight_end":40}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:65:36\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":1935,"byte_end":1939,"line_start":65,"line_end":65,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":36,"highlight_end":40}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:65:36\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::chef::Chef, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":1915,"byte_end":2022,"line_start":65,"line_end":69,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":16,"highlight_end":42},{"text":"        \"SELECT * FROM chefs WHERE user_id = $1\"","highlight_start":1,"highlight_end":49},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(*user_id)","highlight_start":1,"highlight_end":20},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":2022,"byte_end":2036,"line_start":69,"line_end":69,"column_start":6,"column_end":20,"is_primary":true,"text":[{"text":"    .fetch_optional(pool.get_ref())","highlight_start":6,"highlight_end":20}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/chef.rs","byte_start":186,"byte_end":201,"line_start":8,"line_end":8,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Chef {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::chef::Chef: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::chef::Chef: FromRow<'r, PgRow>`\n`Decimal: Type<Postgres>`\nwhich is required by `models::chef::Chef: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::chef::Chef, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:69:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ________________-\u001b[0m\n \u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \"SELECT * FROM chefs WHERE user_id = $1\"\n \u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     )\n \u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(*user_id)\n \u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_optional(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/chef.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::chef::Chef: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: sqlx::Decode<'_, Postgres>`\n            which is required by `models::chef::Chef: FromRow<'r, PgRow>`\n            `Decimal: Type<Postgres>`\n            which is required by `models::chef::Chef: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":1915,"byte_end":2064,"line_start":65,"line_end":70,"column_start":16,"column_end":12,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":16,"highlight_end":42},{"text":"        \"SELECT * FROM chefs WHERE user_id = $1\"","highlight_start":1,"highlight_end":49},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(*user_id)","highlight_start":1,"highlight_end":20},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:65:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query_as::<_, Chef>(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT * FROM chefs WHERE user_id = $1\"\n\u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(*user_id)\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":3733,"byte_end":3737,"line_start":125,"line_end":125,"column_start":49,"column_end":53,"is_primary":true,"text":[{"text":"    let mut query_builder = sqlx::query_as::<_, Chef>(&query);","highlight_start":49,"highlight_end":53}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:125:49\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let mut query_builder = sqlx::query_as::<_, Chef>(&query);\n    \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":3733,"byte_end":3737,"line_start":125,"line_end":125,"column_start":49,"column_end":53,"is_primary":true,"text":[{"text":"    let mut query_builder = sqlx::query_as::<_, Chef>(&query);","highlight_start":49,"highlight_end":53}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:125:49\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let mut query_builder = sqlx::query_as::<_, Chef>(&query);\n    \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":4371,"byte_end":4375,"line_start":143,"line_end":143,"column_start":44,"column_end":48,"is_primary":true,"text":[{"text":"        query_builder = query_builder.bind(rate);","highlight_start":44,"highlight_end":48}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":4366,"byte_end":4370,"line_start":143,"line_end":143,"column_start":39,"column_end":43,"is_primary":false,"text":[{"text":"        query_builder = query_builder.bind(rate);","highlight_start":39,"highlight_end":43}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 41 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&Decimal` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Encode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:143:44\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         query_builder = query_builder.bind(rate);\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, Postgres>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n              `&'a str` implements `Encode<'a, sqlx::Any>`\n              `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n              `&T` implements `Encode<'q, DB>`\n              `&[T]` implements `Encode<'q, Postgres>`\n              `&[u8]` implements `Encode<'_, Postgres>`\n              `&str` implements `Encode<'_, Postgres>`\n              `Box<[u8]>` implements `Encode<'_, Postgres>`\n              `Box<str>` implements `Encode<'_, Postgres>`\n            and 41 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Decimal` to implement `Encode<'_, Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":4371,"byte_end":4375,"line_start":143,"line_end":143,"column_start":44,"column_end":48,"is_primary":true,"text":[{"text":"        query_builder = query_builder.bind(rate);","highlight_start":44,"highlight_end":48}],"label":"the trait `Type<Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":4366,"byte_end":4370,"line_start":143,"line_end":143,"column_start":39,"column_end":43,"is_primary":false,"text":[{"text":"        query_builder = query_builder.bind(rate);","highlight_start":39,"highlight_end":43}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&Decimal` to implement `Type<Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1583,"byte_end":1591,"line_start":54,"line_end":54,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/chef.rs","byte_start":4371,"byte_end":4371,"line_start":143,"line_end":143,"column_start":44,"column_end":44,"is_primary":true,"text":[{"text":"        query_builder = query_builder.bind(rate);","highlight_start":44,"highlight_end":44}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":4375,"byte_end":4375,"line_start":143,"line_end":143,"column_start":48,"column_end":48,"is_primary":true,"text":[{"text":"        query_builder = query_builder.bind(rate);","highlight_start":48,"highlight_end":48}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:143:44\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         query_builder = query_builder.bind(rate);\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&Decimal` to implement `Type<Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:49\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        query_builder = query_builder.bind(\u001b[92m(\u001b[0mrate\u001b[92m,)\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[92m+\u001b[0m    \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::chef::Chef, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":4560,"byte_end":4583,"line_start":151,"line_end":152,"column_start":16,"column_end":10,"is_primary":false,"text":[{"text":"    let chef = query_builder","highlight_start":16,"highlight_end":29},{"text":"        .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":4583,"byte_end":4597,"line_start":152,"line_end":152,"column_start":10,"column_end":24,"is_primary":true,"text":[{"text":"        .fetch_optional(pool.get_ref())","highlight_start":10,"highlight_end":24}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/chef.rs","byte_start":186,"byte_end":201,"line_start":8,"line_end":8,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Chef {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::chef::Chef: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::chef::Chef: FromRow<'r, PgRow>`\n`Decimal: Type<Postgres>`\nwhich is required by `models::chef::Chef: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::chef::Chef, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:152:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m151\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = query_builder\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ________________-\u001b[0m\n\u001b[1m\u001b[94m152\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_optional(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/chef.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::chef::Chef: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: sqlx::Decode<'_, Postgres>`\n            which is required by `models::chef::Chef: FromRow<'r, PgRow>`\n            `Decimal: Type<Postgres>`\n            which is required by `models::chef::Chef: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":4560,"byte_end":4629,"line_start":151,"line_end":153,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    let chef = query_builder","highlight_start":16,"highlight_end":29},{"text":"        .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":40},{"text":"        .await?","highlight_start":1,"highlight_end":16}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:151:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m151\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = query_builder\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m152\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m153\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":4924,"byte_end":4928,"line_start":163,"line_end":163,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":36,"highlight_end":40}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:163:36\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":4924,"byte_end":4928,"line_start":163,"line_end":163,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":36,"highlight_end":40}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/chef.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/chef.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Chef {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:163:36\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::chef::Chef` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/chef.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, _, models::chef::Chef, _>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":4904,"byte_end":5034,"line_start":163,"line_end":167,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":16,"highlight_end":42},{"text":"        \"SELECT * FROM chefs WHERE slug = $1 AND is_active = true\"","highlight_start":1,"highlight_end":67},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(slug.as_str())","highlight_start":1,"highlight_end":25},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/chef.rs","byte_start":5034,"byte_end":5048,"line_start":167,"line_end":167,"column_start":6,"column_end":20,"is_primary":true,"text":[{"text":"    .fetch_optional(pool.get_ref())","highlight_start":6,"highlight_end":20}],"label":"method cannot be called on `QueryAs<'_, _, models::chef::Chef, _>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/chef.rs","byte_start":186,"byte_end":201,"line_start":8,"line_end":8,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Chef {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::chef::Chef: FromRow<'r, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<_>` or `Decimal: sqlx::Decode<'_, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: sqlx::Decode<'_, _>`\nwhich is required by `models::chef::Chef: FromRow<'r, _>`\n`Decimal: Type<_>`\nwhich is required by `models::chef::Chef: FromRow<'r, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, _, models::chef::Chef, _>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:167:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ________________-\u001b[0m\n\u001b[1m\u001b[94m164\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \"SELECT * FROM chefs WHERE slug = $1 AND is_active = true\"\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     )\n\u001b[1m\u001b[94m166\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(slug.as_str())\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_optional(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, _, models::chef::Chef, _>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/chef.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Chef {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::chef::Chef: FromRow<'r, _>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<_>` or `Decimal: sqlx::Decode<'_, _>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: sqlx::Decode<'_, _>`\n            which is required by `models::chef::Chef: FromRow<'r, _>`\n            `Decimal: Type<_>`\n            which is required by `models::chef::Chef: FromRow<'r, _>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":4904,"byte_end":5076,"line_start":163,"line_end":168,"column_start":16,"column_end":12,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":16,"highlight_end":42},{"text":"        \"SELECT * FROM chefs WHERE slug = $1 AND is_active = true\"","highlight_start":1,"highlight_end":67},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(slug.as_str())","highlight_start":1,"highlight_end":25},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:163:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query_as::<_, Chef>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m164\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT * FROM chefs WHERE slug = $1 AND is_active = true\"\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m166\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(slug.as_str())\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":466,"byte_end":600,"line_start":18,"line_end":23,"column_start":16,"column_end":12,"is_primary":true,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT id FROM chefs WHERE user_id = $1\",","highlight_start":1,"highlight_end":51},{"text":"        user_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:18:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id FROM chefs WHERE user_id = $1\",\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":716,"byte_end":720,"line_start":26,"line_end":26,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let menu = sqlx::query_as::<_, Menu>(","highlight_start":36,"highlight_end":40}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/menu.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Menu {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:26:36\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let menu = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/menu.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Menu {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":716,"byte_end":720,"line_start":26,"line_end":26,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let menu = sqlx::query_as::<_, Menu>(","highlight_start":36,"highlight_end":40}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/menu.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Menu {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:26:36\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let menu = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/menu.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Menu {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `std::option::Option<Decimal>: Encode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1124,"byte_end":1145,"line_start":39,"line_end":39,"column_start":12,"column_end":33,"is_primary":true,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":12,"highlight_end":33}],"label":"the trait `Encode<'_, _>` is not implemented for `std::option::Option<Decimal>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":1118,"byte_end":1122,"line_start":39,"line_end":39,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `std::option::Option<T>` implements `Encode<'_, Postgres>`\n  `std::option::Option<T>` implements `Encode<'_, sqlx::Any>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<Decimal>` to implement `Encode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `std::option::Option<Decimal>: Encode<'_, _>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:39:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&data.price_per_person)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, _>` is not implemented for `std::option::Option<Decimal>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n             `std::option::Option<T>` implements `Encode<'_, Postgres>`\n             `std::option::Option<T>` implements `Encode<'_, sqlx::Any>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<Decimal>` to implement `Encode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1124,"byte_end":1145,"line_start":39,"line_end":39,"column_start":12,"column_end":33,"is_primary":true,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":12,"highlight_end":33}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":1118,"byte_end":1122,"line_start":39,"line_end":39,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1583,"byte_end":1591,"line_start":54,"line_end":54,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1123,"byte_end":1123,"line_start":39,"line_end":39,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":1145,"byte_end":1145,"line_start":39,"line_end":39,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:39:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&data.price_per_person)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n             `&T` implements `Type<DB>`\n             `()` implements `Type<Postgres>`\n             `(T1, T2)` implements `Type<Postgres>`\n             `(T1, T2, T3)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n           and 51 others\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .bind(\u001b[92m(\u001b[0m&data.price_per_person\u001b[92m,)\u001b[0m)\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[92m+\u001b[0m                      \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1265,"byte_end":1284,"line_start":43,"line_end":43,"column_start":12,"column_end":31,"is_primary":true,"text":[{"text":"    .bind(&data.duration_hours)","highlight_start":12,"highlight_end":31}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":1259,"byte_end":1263,"line_start":43,"line_end":43,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&data.duration_hours)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 41 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Encode<'_, Postgres>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:43:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&data.duration_hours)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, Postgres>` is not implemented for `Decimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n             `&'a str` implements `Encode<'a, sqlx::Any>`\n             `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n             `&T` implements `Encode<'q, DB>`\n             `&[T]` implements `Encode<'q, Postgres>`\n             `&[u8]` implements `Encode<'_, Postgres>`\n             `&str` implements `Encode<'_, Postgres>`\n             `Box<[u8]>` implements `Encode<'_, Postgres>`\n             `Box<str>` implements `Encode<'_, Postgres>`\n           and 41 others\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1265,"byte_end":1284,"line_start":43,"line_end":43,"column_start":12,"column_end":31,"is_primary":true,"text":[{"text":"    .bind(&data.duration_hours)","highlight_start":12,"highlight_end":31}],"label":"the trait `Type<Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":1259,"byte_end":1263,"line_start":43,"line_end":43,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&data.duration_hours)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<Postgres>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:43:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&data.duration_hours)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `Decimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n             `&T` implements `Type<DB>`\n             `()` implements `Type<Postgres>`\n             `(T1, T2)` implements `Type<Postgres>`\n             `(T1, T2, T3)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n           and 51 others\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<Decimal>` to implement `Encode<'_, Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::menu::Menu, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":696,"byte_end":1307,"line_start":26,"line_end":45,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let menu = sqlx::query_as::<_, Menu>(","highlight_start":16,"highlight_end":42},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        INSERT INTO menus (","highlight_start":1,"highlight_end":28},{"text":"            chef_id, name, description, price_per_person, minimum_guests,","highlight_start":1,"highlight_end":74},{"text":"            cuisine_type, dietary_options, duration_hours, is_active, created_at, updated_at","highlight_start":1,"highlight_end":93},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())","highlight_start":1,"highlight_end":66},{"text":"        RETURNING *","highlight_start":1,"highlight_end":20},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(chef.id)","highlight_start":1,"highlight_end":19},{"text":"    .bind(&data.name)","highlight_start":1,"highlight_end":22},{"text":"    .bind(&data.description)","highlight_start":1,"highlight_end":29},{"text":"    .bind(&data.price_per_person)","highlight_start":1,"highlight_end":34},{"text":"    .bind(data.minimum_guests.unwrap_or(2))","highlight_start":1,"highlight_end":44},{"text":"    .bind(&data.cuisine_type)","highlight_start":1,"highlight_end":30},{"text":"    .bind(&data.dietary_options)","highlight_start":1,"highlight_end":33},{"text":"    .bind(&data.duration_hours)","highlight_start":1,"highlight_end":32},{"text":"    .bind(true)","highlight_start":1,"highlight_end":16},{"text":"    .fetch_one(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":1307,"byte_end":1316,"line_start":45,"line_end":45,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(pool.get_ref())","highlight_start":6,"highlight_end":15}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/menu.rs","byte_start":186,"byte_end":201,"line_start":8,"line_end":8,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Menu {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::menu::Menu: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::menu::Menu: FromRow<'r, PgRow>`\n`Decimal: Type<Postgres>`\nwhich is required by `models::menu::Menu: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::menu::Menu, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:45:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let menu = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ________________-\u001b[0m\n \u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n \u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         INSERT INTO menus (\n \u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             chef_id, name, description, price_per_person, minimum_guests,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(true)\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/menu.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Menu {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::menu::Menu: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: sqlx::Decode<'_, Postgres>`\n            which is required by `models::menu::Menu: FromRow<'r, PgRow>`\n            `Decimal: Type<Postgres>`\n            which is required by `models::menu::Menu: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":231,"byte_end":376,"line_start":10,"line_end":14,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn create_menu(","highlight_start":1,"highlight_end":26},{"text":"    req: HttpRequest,","highlight_start":1,"highlight_end":22},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":"    data: web::Json<CreateMenu>,","highlight_start":1,"highlight_end":33},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1383,"byte_end":1387,"line_start":48,"line_end":48,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Created().json(menu))","highlight_start":37,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/menu.rs","byte_start":693,"byte_end":693,"line_start":26,"line_end":26,"column_start":13,"column_end":13,"is_primary":true,"text":[{"text":"    let menu = sqlx::query_as::<_, Menu>(","highlight_start":13,"highlight_end":13}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:10:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn create_menu(\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     req: HttpRequest,\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     data: web::Json<CreateMenu>,\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:48:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Created().json(menu))\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let menu\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Menu>(\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1569,"byte_end":1703,"line_start":57,"line_end":62,"column_start":16,"column_end":12,"is_primary":true,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT id FROM chefs WHERE user_id = $1\",","highlight_start":1,"highlight_end":51},{"text":"        user_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:57:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id FROM chefs WHERE user_id = $1\",\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1820,"byte_end":1824,"line_start":65,"line_end":65,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"    let menus = sqlx::query_as::<_, Menu>(","highlight_start":37,"highlight_end":41}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/menu.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Menu {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:65:37\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let menus = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/menu.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Menu {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1820,"byte_end":1824,"line_start":65,"line_end":65,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"    let menus = sqlx::query_as::<_, Menu>(","highlight_start":37,"highlight_end":41}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/menu.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Menu {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:65:37\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let menus = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/menu.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Menu {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_all` exists for struct `QueryAs<'_, _, models::menu::Menu, _>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1800,"byte_end":1931,"line_start":65,"line_end":69,"column_start":17,"column_end":6,"is_primary":false,"text":[{"text":"    let menus = sqlx::query_as::<_, Menu>(","highlight_start":17,"highlight_end":43},{"text":"        \"SELECT * FROM menus WHERE chef_id = $1 ORDER BY created_at DESC\"","highlight_start":1,"highlight_end":74},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(chef.id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_all(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":1931,"byte_end":1940,"line_start":69,"line_end":69,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_all(pool.get_ref())","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, _, models::menu::Menu, _>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/menu.rs","byte_start":186,"byte_end":201,"line_start":8,"line_end":8,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Menu {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::menu::Menu: FromRow<'r, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<_>` or `Decimal: sqlx::Decode<'_, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: sqlx::Decode<'_, _>`\nwhich is required by `models::menu::Menu: FromRow<'r, _>`\n`Decimal: Type<_>`\nwhich is required by `models::menu::Menu: FromRow<'r, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_all` exists for struct `QueryAs<'_, _, models::menu::Menu, _>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:69:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let menus = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _________________-\u001b[0m\n \u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \"SELECT * FROM menus WHERE chef_id = $1 ORDER BY created_at DESC\"\n \u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     )\n \u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(chef.id)\n \u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_all(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, _, models::menu::Menu, _>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/menu.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Menu {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::menu::Menu: FromRow<'r, _>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<_>` or `Decimal: sqlx::Decode<'_, _>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: sqlx::Decode<'_, _>`\n            which is required by `models::menu::Menu: FromRow<'r, _>`\n            `Decimal: Type<_>`\n            which is required by `models::menu::Menu: FromRow<'r, _>`\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1393,"byte_end":1508,"line_start":51,"line_end":54,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn get_chef_menus(","highlight_start":1,"highlight_end":29},{"text":"    req: HttpRequest,","highlight_start":1,"highlight_end":22},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/menu.rs","byte_start":2002,"byte_end":2007,"line_start":72,"line_end":72,"column_start":32,"column_end":37,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Ok().json(menus))","highlight_start":32,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1797,"byte_end":1797,"line_start":65,"line_end":65,"column_start":14,"column_end":14,"is_primary":true,"text":[{"text":"    let menus = sqlx::query_as::<_, Menu>(","highlight_start":14,"highlight_end":14}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:51:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn get_chef_menus(\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     req: HttpRequest,\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:72:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Ok().json(menus))\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let menus\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Menu>(\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":2273,"byte_end":2502,"line_start":84,"line_end":92,"column_start":16,"column_end":12,"is_primary":true,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        *menu_id","highlight_start":1,"highlight_end":17},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:84:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":3027,"byte_end":3031,"line_start":103,"line_end":103,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let menu = sqlx::query_as::<_, Menu>(","highlight_start":36,"highlight_end":40}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/menu.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Menu {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:103:36\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let menu = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/menu.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Menu {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":3027,"byte_end":3031,"line_start":103,"line_end":103,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"    let menu = sqlx::query_as::<_, Menu>(","highlight_start":36,"highlight_end":40}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/menu.rs","byte_start":169,"byte_end":176,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/menu.rs","byte_start":197,"byte_end":201,"line_start":8,"line_end":8,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct Menu {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:103:36\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let menu = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::menu::Menu` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/menu.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Menu {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `std::option::Option<Decimal>: Encode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":3222,"byte_end":3243,"line_start":111,"line_end":111,"column_start":12,"column_end":33,"is_primary":true,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":12,"highlight_end":33}],"label":"the trait `Encode<'_, _>` is not implemented for `std::option::Option<Decimal>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":3216,"byte_end":3220,"line_start":111,"line_end":111,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `std::option::Option<T>` implements `Encode<'_, Postgres>`\n  `std::option::Option<T>` implements `Encode<'_, sqlx::Any>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<Decimal>` to implement `Encode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `std::option::Option<Decimal>: Encode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:111:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&data.price_per_person)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, _>` is not implemented for `std::option::Option<Decimal>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n              `std::option::Option<T>` implements `Encode<'_, Postgres>`\n              `std::option::Option<T>` implements `Encode<'_, sqlx::Any>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<Decimal>` to implement `Encode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":3222,"byte_end":3243,"line_start":111,"line_end":111,"column_start":12,"column_end":33,"is_primary":true,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":12,"highlight_end":33}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":3216,"byte_end":3220,"line_start":111,"line_end":111,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<Decimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1583,"byte_end":1591,"line_start":54,"line_end":54,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/menu.rs","byte_start":3221,"byte_end":3221,"line_start":111,"line_end":111,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":3243,"byte_end":3243,"line_start":111,"line_end":111,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"    .bind(&data.price_per_person)","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:111:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&data.price_per_person)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<Decimal>` to implement `Type<_>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<Decimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:49\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .bind(\u001b[92m(\u001b[0m&data.price_per_person\u001b[92m,)\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[92m+\u001b[0m                      \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::menu::Menu, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":3007,"byte_end":3297,"line_start":103,"line_end":114,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let menu = sqlx::query_as::<_, Menu>(","highlight_start":16,"highlight_end":42},{"text":"        &format!(","highlight_start":1,"highlight_end":18},{"text":"            \"UPDATE menus SET {} WHERE id = $5 RETURNING *\",","highlight_start":1,"highlight_end":61},{"text":"            updates.join(\", \")","highlight_start":1,"highlight_end":31},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(&data.name)","highlight_start":1,"highlight_end":22},{"text":"    .bind(&data.description)","highlight_start":1,"highlight_end":29},{"text":"    .bind(&data.price_per_person)","highlight_start":1,"highlight_end":34},{"text":"    .bind(&data.is_active)","highlight_start":1,"highlight_end":27},{"text":"    .bind(*menu_id)","highlight_start":1,"highlight_end":20},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/menu.rs","byte_start":3297,"byte_end":3311,"line_start":114,"line_end":114,"column_start":6,"column_end":20,"is_primary":true,"text":[{"text":"    .fetch_optional(pool.get_ref())","highlight_start":6,"highlight_end":20}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/menu.rs","byte_start":186,"byte_end":201,"line_start":8,"line_end":8,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Menu {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::menu::Menu: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::menu::Menu: FromRow<'r, PgRow>`\n`Decimal: Type<Postgres>`\nwhich is required by `models::menu::Menu: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::menu::Menu, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:114:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let menu = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ________________-\u001b[0m\n\u001b[1m\u001b[94m104\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         &format!(\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             \"UPDATE menus SET {} WHERE id = $5 RETURNING *\",\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             updates.join(\", \")\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(*menu_id)\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_optional(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/menu.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Menu {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::menu::Menu: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: sqlx::Decode<'_, Postgres>`\n            which is required by `models::menu::Menu: FromRow<'r, PgRow>`\n            `Decimal: Type<Postgres>`\n            which is required by `models::menu::Menu: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":3007,"byte_end":3339,"line_start":103,"line_end":115,"column_start":16,"column_end":12,"is_primary":true,"text":[{"text":"    let menu = sqlx::query_as::<_, Menu>(","highlight_start":16,"highlight_end":42},{"text":"        &format!(","highlight_start":1,"highlight_end":18},{"text":"            \"UPDATE menus SET {} WHERE id = $5 RETURNING *\",","highlight_start":1,"highlight_end":61},{"text":"            updates.join(\", \")","highlight_start":1,"highlight_end":31},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(&data.name)","highlight_start":1,"highlight_end":22},{"text":"    .bind(&data.description)","highlight_start":1,"highlight_end":29},{"text":"    .bind(&data.price_per_person)","highlight_start":1,"highlight_end":34},{"text":"    .bind(&data.is_active)","highlight_start":1,"highlight_end":27},{"text":"    .bind(*menu_id)","highlight_start":1,"highlight_end":20},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:103:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let menu = sqlx::query_as::<_, Menu>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m104\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         &format!(\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"UPDATE menus SET {} WHERE id = $5 RETURNING *\",\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             updates.join(\", \")\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":3680,"byte_end":3909,"line_start":129,"line_end":137,"column_start":16,"column_end":12,"is_primary":true,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        *menu_id","highlight_start":1,"highlight_end":17},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:129:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m130\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m131\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m132\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m137\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu_item.rs","byte_start":513,"byte_end":742,"line_start":19,"line_end":27,"column_start":17,"column_end":12,"is_primary":true,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        *menu_id","highlight_start":1,"highlight_end":17},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu_item.rs:19:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu_item.rs","byte_start":2164,"byte_end":2392,"line_start":77,"line_end":85,"column_start":17,"column_end":12,"is_primary":true,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        menu_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu_item.rs:77:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/menu_item.rs","byte_start":3585,"byte_end":3813,"line_start":125,"line_end":133,"column_start":17,"column_end":12,"is_primary":true,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN menus m ON m.chef_id = c.id","highlight_start":1,"highlight_end":48},{"text":"         WHERE c.user_id = $1 AND m.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        menu_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu_item.rs:125:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m126\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m127\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN menus m ON m.chef_id = c.id\n\u001b[1m\u001b[94m128\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND m.id = $2\",\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m132\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m133\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":534,"byte_end":709,"line_start":18,"line_end":23,"column_start":16,"column_end":12,"is_primary":true,"text":[{"text":"    let chef = sqlx::query!(","highlight_start":16,"highlight_end":29},{"text":"        \"SELECT hourly_rate, minimum_hours FROM chefs WHERE id = $1 AND is_active = true\",","highlight_start":1,"highlight_end":91},{"text":"        *chef_id","highlight_start":1,"highlight_end":17},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:18:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let chef = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT hourly_rate, minimum_hours FROM chefs WHERE id = $1 AND is_active = true\",\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         *chef_id\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":1538,"byte_end":1546,"line_start":48,"line_end":48,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"    if conflict.is_some() {","highlight_start":8,"highlight_end":16}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/booking.rs","byte_start":1197,"byte_end":1205,"line_start":33,"line_end":33,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    let conflict = sqlx::query!(","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving `conflict` an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/booking.rs","byte_start":1205,"byte_end":1205,"line_start":33,"line_end":33,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    let conflict = sqlx::query!(","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:33:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let conflict = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     if conflict.is_some() {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving `conflict` an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let conflict\u001b[92m: /* Type */\u001b[0m = sqlx::query!(\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":1694,"byte_end":1701,"line_start":52,"line_end":52,"column_start":39,"column_end":46,"is_primary":true,"text":[{"text":"    let booking = sqlx::query_as::<_, Booking>(","highlight_start":39,"highlight_end":46}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/booking.rs","byte_start":219,"byte_end":226,"line_start":8,"line_end":8,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Booking {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:52:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let booking = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/booking.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Booking {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":1694,"byte_end":1701,"line_start":52,"line_end":52,"column_start":39,"column_end":46,"is_primary":true,"text":[{"text":"    let booking = sqlx::query_as::<_, Booking>(","highlight_start":39,"highlight_end":46}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/booking.rs","byte_start":219,"byte_end":226,"line_start":8,"line_end":8,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Booking {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:52:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let booking = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/booking.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Booking {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":2387,"byte_end":2403,"line_start":71,"line_end":71,"column_start":11,"column_end":27,"is_primary":true,"text":[{"text":"    .bind(duration_decimal)","highlight_start":11,"highlight_end":27}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/booking.rs","byte_start":2382,"byte_end":2386,"line_start":71,"line_end":71,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(duration_decimal)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 41 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Encode<'_, Postgres>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:71:11\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(duration_decimal)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, Postgres>` is not implemented for `Decimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n             `&'a str` implements `Encode<'a, sqlx::Any>`\n             `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n             `&T` implements `Encode<'q, DB>`\n             `&[T]` implements `Encode<'q, Postgres>`\n             `&[u8]` implements `Encode<'_, Postgres>`\n             `&str` implements `Encode<'_, Postgres>`\n             `Box<[u8]>` implements `Encode<'_, Postgres>`\n             `Box<str>` implements `Encode<'_, Postgres>`\n           and 41 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":2387,"byte_end":2403,"line_start":71,"line_end":71,"column_start":11,"column_end":27,"is_primary":true,"text":[{"text":"    .bind(duration_decimal)","highlight_start":11,"highlight_end":27}],"label":"the trait `Type<Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/booking.rs","byte_start":2382,"byte_end":2386,"line_start":71,"line_end":71,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(duration_decimal)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1583,"byte_end":1591,"line_start":54,"line_end":54,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/booking.rs","byte_start":2387,"byte_end":2387,"line_start":71,"line_end":71,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"    .bind(duration_decimal)","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/booking.rs","byte_start":2403,"byte_end":2403,"line_start":71,"line_end":71,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"    .bind(duration_decimal)","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<Postgres>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:71:11\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(duration_decimal)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `Decimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n             `&T` implements `Type<DB>`\n             `()` implements `Type<Postgres>`\n             `(T1, T2)` implements `Type<Postgres>`\n             `(T1, T2, T3)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n           and 51 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .bind(\u001b[92m(\u001b[0mduration_decimal\u001b[92m,)\u001b[0m)\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[92m+\u001b[0m                \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::booking::Booking, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":1674,"byte_end":2534,"line_start":52,"line_end":76,"column_start":19,"column_end":6,"is_primary":false,"text":[{"text":"    let booking = sqlx::query_as::<_, Booking>(","highlight_start":19,"highlight_end":48},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        INSERT INTO bookings (","highlight_start":1,"highlight_end":31},{"text":"            chef_id, customer_id, menu_id, customer_name, customer_email,","highlight_start":1,"highlight_end":74},{"text":"            customer_phone, event_date, event_time, duration_hours,","highlight_start":1,"highlight_end":68},{"text":"            number_of_guests, location_address, special_requests,","highlight_start":1,"highlight_end":66},{"text":"            total_price, status, payment_status, created_at, updated_at","highlight_start":1,"highlight_end":72},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"        VALUES ($1, NULL, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 'pending', 'pending', NOW(), NOW())","highlight_start":1,"highlight_end":109},{"text":"        RETURNING *","highlight_start":1,"highlight_end":20},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(*chef_id)","highlight_start":1,"highlight_end":20},{"text":"    .bind(&data.menu_id)","highlight_start":1,"highlight_end":25},{"text":"    .bind(&data.customer_name)","highlight_start":1,"highlight_end":31},{"text":"    .bind(&data.customer_email)","highlight_start":1,"highlight_end":32},{"text":"    .bind(&data.customer_phone)","highlight_start":1,"highlight_end":32},{"text":"    .bind(data.event_date)","highlight_start":1,"highlight_end":27},{"text":"    .bind(data.event_time)","highlight_start":1,"highlight_end":27},{"text":"    .bind(duration_decimal)","highlight_start":1,"highlight_end":28},{"text":"    .bind(data.number_of_guests)","highlight_start":1,"highlight_end":33},{"text":"    .bind(&data.location_address)","highlight_start":1,"highlight_end":34},{"text":"    .bind(&data.special_requests)","highlight_start":1,"highlight_end":34},{"text":"    .bind(total_price)","highlight_start":1,"highlight_end":23},{"text":"    .fetch_one(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/booking.rs","byte_start":2534,"byte_end":2543,"line_start":76,"line_end":76,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(pool.get_ref())","highlight_start":6,"highlight_end":15}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/booking.rs","byte_start":208,"byte_end":226,"line_start":8,"line_end":8,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Booking {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `models::booking::Booking: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: Type<Postgres>`\n`Decimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::booking::Booking, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:76:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let booking = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ___________________-\u001b[0m\n \u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         INSERT INTO bookings (\n \u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             chef_id, customer_id, menu_id, customer_name, customer_email,\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(total_price)\n \u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/booking.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Booking {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::booking::Booking: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: Type<Postgres>`\n            `Decimal: sqlx::Decode<'_, Postgres>`\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":324,"byte_end":483,"line_start":12,"line_end":16,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn create_booking(","highlight_start":1,"highlight_end":29},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":"    chef_id: web::Path<Uuid>,","highlight_start":1,"highlight_end":30},{"text":"    data: web::Json<CreateBooking>,","highlight_start":1,"highlight_end":36},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/booking.rs","byte_start":2610,"byte_end":2617,"line_start":79,"line_end":79,"column_start":37,"column_end":44,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Created().json(booking))","highlight_start":37,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/booking.rs","byte_start":1671,"byte_end":1671,"line_start":52,"line_end":52,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    let booking = sqlx::query_as::<_, Booking>(","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:12:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn create_booking(\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     chef_id: web::Path<Uuid>,\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     data: web::Json<CreateBooking>,\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:79:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Created().json(booking))\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let booking\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Booking>(\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":3771,"byte_end":3779,"line_start":116,"line_end":116,"column_start":44,"column_end":52,"is_primary":false,"text":[{"text":"        let booked_times: Vec<NaiveTime> = bookings","highlight_start":44,"highlight_end":52}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/booking.rs","byte_start":3219,"byte_end":3227,"line_start":96,"line_end":96,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    let bookings = sqlx::query!(","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving `bookings` an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/booking.rs","byte_start":3227,"byte_end":3227,"line_start":96,"line_end":96,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    let bookings = sqlx::query!(","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:96:9\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bookings = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let booked_times: Vec<NaiveTime> = bookings\n    \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving `bookings` an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let bookings\u001b[92m: /* Type */\u001b[0m = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":4957,"byte_end":5121,"line_start":156,"line_end":162,"column_start":17,"column_end":12,"is_primary":true,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT id FROM chefs WHERE id = $1 AND user_id = $2\",","highlight_start":1,"highlight_end":63},{"text":"        *chef_id,","highlight_start":1,"highlight_end":18},{"text":"        user_id","highlight_start":1,"highlight_end":16},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:156:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT id FROM chefs WHERE id = $1 AND user_id = $2\",\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         *chef_id,\n\u001b[1m\u001b[94m159\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         user_id\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m161\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m162\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":5237,"byte_end":5244,"line_start":165,"line_end":165,"column_start":40,"column_end":47,"is_primary":true,"text":[{"text":"    let bookings = sqlx::query_as::<_, Booking>(","highlight_start":40,"highlight_end":47}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/booking.rs","byte_start":219,"byte_end":226,"line_start":8,"line_end":8,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Booking {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:165:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bookings = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/booking.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Booking {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":5237,"byte_end":5244,"line_start":165,"line_end":165,"column_start":40,"column_end":47,"is_primary":true,"text":[{"text":"    let bookings = sqlx::query_as::<_, Booking>(","highlight_start":40,"highlight_end":47}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/booking.rs","byte_start":219,"byte_end":226,"line_start":8,"line_end":8,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Booking {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:165:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bookings = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/booking.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Booking {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_all` exists for struct `QueryAs<'_, Postgres, models::booking::Booking, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":5217,"byte_end":5372,"line_start":165,"line_end":169,"column_start":20,"column_end":6,"is_primary":false,"text":[{"text":"    let bookings = sqlx::query_as::<_, Booking>(","highlight_start":20,"highlight_end":49},{"text":"        \"SELECT * FROM bookings WHERE chef_id = $1 ORDER BY event_date DESC, event_time DESC\"","highlight_start":1,"highlight_end":94},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(*chef_id)","highlight_start":1,"highlight_end":20},{"text":"    .fetch_all(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/booking.rs","byte_start":5372,"byte_end":5381,"line_start":169,"line_end":169,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_all(pool.get_ref())","highlight_start":6,"highlight_end":15}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/booking.rs","byte_start":208,"byte_end":226,"line_start":8,"line_end":8,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Booking {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `models::booking::Booking: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: Type<Postgres>`\n`Decimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_all` exists for struct `QueryAs<'_, Postgres, models::booking::Booking, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:169:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bookings = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ____________________-\u001b[0m\n\u001b[1m\u001b[94m166\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \"SELECT * FROM bookings WHERE chef_id = $1 ORDER BY event_date DESC, event_time DESC\"\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     )\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(*chef_id)\n\u001b[1m\u001b[94m169\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_all(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/booking.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Booking {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::booking::Booking: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: Type<Postgres>`\n            `Decimal: sqlx::Decode<'_, Postgres>`\n\n"}
{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":4723,"byte_end":4871,"line_start":148,"line_end":152,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn get_chef_bookings(","highlight_start":1,"highlight_end":32},{"text":"    req: HttpRequest,","highlight_start":1,"highlight_end":22},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":"    chef_id: web::Path<Uuid>,","highlight_start":1,"highlight_end":30},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/booking.rs","byte_start":5443,"byte_end":5451,"line_start":172,"line_end":172,"column_start":32,"column_end":40,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Ok().json(bookings))","highlight_start":32,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/booking.rs","byte_start":5214,"byte_end":5214,"line_start":165,"line_end":165,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    let bookings = sqlx::query_as::<_, Booking>(","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:148:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m148\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn get_chef_bookings(\n\u001b[1m\u001b[94m149\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     req: HttpRequest,\n\u001b[1m\u001b[94m150\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m151\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     chef_id: web::Path<Uuid>,\n\u001b[1m\u001b[94m152\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:172:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m172\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Ok().json(bookings))\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let bookings\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":5727,"byte_end":5962,"line_start":184,"line_end":192,"column_start":17,"column_end":12,"is_primary":true,"text":[{"text":"    let _chef = sqlx::query!(","highlight_start":17,"highlight_end":30},{"text":"        \"SELECT c.id FROM chefs c","highlight_start":1,"highlight_end":34},{"text":"         INNER JOIN bookings b ON b.chef_id = c.id","highlight_start":1,"highlight_end":51},{"text":"         WHERE c.user_id = $1 AND b.id = $2\",","highlight_start":1,"highlight_end":46},{"text":"        user_id,","highlight_start":1,"highlight_end":17},{"text":"        *booking_id","highlight_start":1,"highlight_end":20},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:184:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m184\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let _chef = sqlx::query!(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _________________^\u001b[0m\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT c.id FROM chefs c\n\u001b[1m\u001b[94m186\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          INNER JOIN bookings b ON b.chef_id = c.id\n\u001b[1m\u001b[94m187\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m          WHERE c.user_id = $1 AND b.id = $2\",\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m191\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":6077,"byte_end":6084,"line_start":195,"line_end":195,"column_start":39,"column_end":46,"is_primary":true,"text":[{"text":"    let booking = sqlx::query_as::<_, Booking>(","highlight_start":39,"highlight_end":46}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/booking.rs","byte_start":219,"byte_end":226,"line_start":8,"line_end":8,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Booking {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:195:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let booking = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 49 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/booking.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Booking {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":6077,"byte_end":6084,"line_start":195,"line_end":195,"column_start":39,"column_end":46,"is_primary":true,"text":[{"text":"    let booking = sqlx::query_as::<_, Booking>(","highlight_start":39,"highlight_end":46}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 51 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/booking.rs","byte_start":191,"byte_end":198,"line_start":7,"line_end":7,"column_start":41,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, FromRow, Clone)]","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/booking.rs","byte_start":219,"byte_end":226,"line_start":8,"line_end":8,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Booking {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:195:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let booking = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 51 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::booking::Booking` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/booking.rs:7:41\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, FromRow, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Booking {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::booking::Booking, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":6057,"byte_end":6399,"line_start":195,"line_end":208,"column_start":19,"column_end":6,"is_primary":false,"text":[{"text":"    let booking = sqlx::query_as::<_, Booking>(","highlight_start":19,"highlight_end":48},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        UPDATE bookings","highlight_start":1,"highlight_end":24},{"text":"        SET status = COALESCE($1, status),","highlight_start":1,"highlight_end":43},{"text":"            payment_status = COALESCE($2, payment_status),","highlight_start":1,"highlight_end":59},{"text":"            updated_at = NOW()","highlight_start":1,"highlight_end":31},{"text":"        WHERE id = $3","highlight_start":1,"highlight_end":22},{"text":"        RETURNING *","highlight_start":1,"highlight_end":20},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(&data.status)","highlight_start":1,"highlight_end":24},{"text":"    .bind(&data.payment_status)","highlight_start":1,"highlight_end":32},{"text":"    .bind(*booking_id)","highlight_start":1,"highlight_end":23},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/booking.rs","byte_start":6399,"byte_end":6413,"line_start":208,"line_end":208,"column_start":6,"column_end":20,"is_primary":true,"text":[{"text":"    .fetch_optional(pool.get_ref())","highlight_start":6,"highlight_end":20}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/booking.rs","byte_start":208,"byte_end":226,"line_start":8,"line_end":8,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Booking {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `models::booking::Booking: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs","byte_start":2994,"byte_end":3012,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: Type<Postgres>`\n`Decimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, models::booking::Booking, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:208:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let booking = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ___________________-\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m197\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         UPDATE bookings\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         SET status = COALESCE($1, status),\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m207\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(*booking_id)\n\u001b[1m\u001b[94m208\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_optional(pool.get_ref())\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/booking.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Booking {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::booking::Booking: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/Users/matthewbraun/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.39.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: Type<Postgres>`\n            `Decimal: sqlx::Decode<'_, Postgres>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":6057,"byte_end":6441,"line_start":195,"line_end":209,"column_start":19,"column_end":12,"is_primary":true,"text":[{"text":"    let booking = sqlx::query_as::<_, Booking>(","highlight_start":19,"highlight_end":48},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        UPDATE bookings","highlight_start":1,"highlight_end":24},{"text":"        SET status = COALESCE($1, status),","highlight_start":1,"highlight_end":43},{"text":"            payment_status = COALESCE($2, payment_status),","highlight_start":1,"highlight_end":59},{"text":"            updated_at = NOW()","highlight_start":1,"highlight_end":31},{"text":"        WHERE id = $3","highlight_start":1,"highlight_end":22},{"text":"        RETURNING *","highlight_start":1,"highlight_end":20},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(&data.status)","highlight_start":1,"highlight_end":24},{"text":"    .bind(&data.payment_status)","highlight_start":1,"highlight_end":32},{"text":"    .bind(*booking_id)","highlight_start":1,"highlight_end":23},{"text":"    .fetch_optional(pool.get_ref())","highlight_start":1,"highlight_end":36},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:195:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let booking = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ___________________^\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m197\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         UPDATE bookings\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         SET status = COALESCE($1, status),\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m208\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(pool.get_ref())\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `req` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/middleware/auth.rs","byte_start":494,"byte_end":496,"line_start":18,"line_end":18,"column_start":21,"column_end":23,"is_primary":true,"text":[{"text":"        .ok_or_else(|| {","highlight_start":21,"highlight_end":23}],"label":"move out of `req` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":427,"byte_end":430,"line_start":17,"line_end":17,"column_start":18,"column_end":21,"is_primary":false,"text":[{"text":"    let config = req.app_data::<actix_web::web::Data<Config>>()","highlight_start":18,"highlight_end":21}],"label":"borrow of `req` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":614,"byte_end":617,"line_start":20,"line_end":20,"column_start":21,"column_end":24,"is_primary":false,"text":[{"text":"            (error, req)","highlight_start":21,"highlight_end":24}],"label":"move occurs due to use in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":305,"byte_end":308,"line_start":14,"line_end":14,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    req: ServiceRequest,","highlight_start":5,"highlight_end":8}],"label":"binding `req` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":483,"byte_end":493,"line_start":18,"line_end":18,"column_start":10,"column_end":20,"is_primary":false,"text":[{"text":"        .ok_or_else(|| {","highlight_start":10,"highlight_end":20}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m: cannot move out of `req` because it is borrowed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/middleware/auth.rs:18:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     req: ServiceRequest,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mbinding `req` declared here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let config = req.app_data::<actix_web::web::Data<Config>>()\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mborrow of `req` occurs here\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .ok_or_else(|| {\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mmove out of `req` occurs here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94mborrow later used by call\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let error = actix_web::error::ErrorInternalServerError(\"Configuration not found\");\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             (error, req)\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mmove occurs due to use in closure\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of moved value: `req`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src/middleware/auth.rs","byte_start":494,"byte_end":496,"line_start":18,"line_end":18,"column_start":21,"column_end":23,"is_primary":false,"text":[{"text":"        .ok_or_else(|| {","highlight_start":21,"highlight_end":23}],"label":"value moved into closure here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":614,"byte_end":617,"line_start":20,"line_end":20,"column_start":21,"column_end":24,"is_primary":false,"text":[{"text":"            (error, req)","highlight_start":21,"highlight_end":24}],"label":"variable moved due to use in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":962,"byte_end":965,"line_start":30,"line_end":30,"column_start":29,"column_end":32,"is_primary":false,"text":[{"text":"                    (error, req)","highlight_start":29,"highlight_end":32}],"label":"use occurs due to use in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":831,"byte_end":834,"line_start":28,"line_end":28,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"                .map_err(|_| {","highlight_start":26,"highlight_end":29}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":305,"byte_end":308,"line_start":14,"line_end":14,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    req: ServiceRequest,","highlight_start":5,"highlight_end":8}],"label":"move occurs because `req` has type `ServiceRequest`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m: use of moved value: `req`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/middleware/auth.rs:28:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     req: ServiceRequest,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mmove occurs because `req` has type `ServiceRequest`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .ok_or_else(|| {\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94mvalue moved into closure here\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let error = actix_web::error::ErrorInternalServerError(\"Configuration not found\");\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             (error, req)\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mvariable moved due to use in closure\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 .map_err(|_| {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mvalue used here after move\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let error = actix_web::error::ErrorUnauthorized(\"Invalid user ID in token\");\n\u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     (error, req)\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94muse occurs due to use in closure\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"borrow of moved value: `req`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src/middleware/auth.rs","byte_start":831,"byte_end":834,"line_start":28,"line_end":28,"column_start":26,"column_end":29,"is_primary":false,"text":[{"text":"                .map_err(|_| {","highlight_start":26,"highlight_end":29}],"label":"value moved into closure here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":962,"byte_end":965,"line_start":30,"line_end":30,"column_start":29,"column_end":32,"is_primary":false,"text":[{"text":"                    (error, req)","highlight_start":29,"highlight_end":32}],"label":"variable moved due to use in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":1001,"byte_end":1004,"line_start":33,"line_end":33,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"            req.extensions_mut().insert(AuthenticatedUser { user_id });","highlight_start":13,"highlight_end":16}],"label":"value borrowed here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware/auth.rs","byte_start":305,"byte_end":308,"line_start":14,"line_end":14,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    req: ServiceRequest,","highlight_start":5,"highlight_end":8}],"label":"move occurs because `req` has type `ServiceRequest`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m: borrow of moved value: `req`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/middleware/auth.rs:33:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     req: ServiceRequest,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mmove occurs because `req` has type `ServiceRequest`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 .map_err(|_| {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mvalue moved into closure here\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let error = actix_web::error::ErrorUnauthorized(\"Invalid user ID in token\");\n\u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     (error, req)\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mvariable moved due to use in closure\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             req.extensions_mut().insert(AuthenticatedUser { user_id });\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mvalue borrowed here after move\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of moved value: `config`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1096,"byte_end":1103,"line_start":48,"line_end":48,"column_start":21,"column_end":28,"is_primary":false,"text":[{"text":"    HttpServer::new(move || {","highlight_start":21,"highlight_end":28}],"label":"value moved into closure here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1214,"byte_end":1220,"line_start":51,"line_end":51,"column_start":38,"column_end":44,"is_primary":false,"text":[{"text":"            .app_data(web::Data::new(config.clone()))","highlight_start":38,"highlight_end":44}],"label":"variable moved due to use in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1617,"byte_end":1635,"line_start":59,"line_end":59,"column_start":41,"column_end":59,"is_primary":true,"text":[{"text":"    .bind((config.server.host.as_str(), config.server.port))?","highlight_start":41,"highlight_end":59}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":566,"byte_end":572,"line_start":28,"line_end":28,"column_start":9,"column_end":15,"is_primary":false,"text":[{"text":"    let config = Config::from_env()","highlight_start":9,"highlight_end":15}],"label":"move occurs because `config` has type `config::Config`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value before moving it into the closure","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1096,"byte_end":1096,"line_start":48,"line_end":48,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"    HttpServer::new(move || {","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"{\n    let value = config.clone();\n    ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":1214,"byte_end":1220,"line_start":51,"line_end":51,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"            .app_data(web::Data::new(config.clone()))","highlight_start":38,"highlight_end":44}],"label":null,"suggested_replacement":"value","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/main.rs","byte_start":1575,"byte_end":1575,"line_start":58,"line_end":58,"column_start":6,"column_end":6,"is_primary":true,"text":[{"text":"    })","highlight_start":6,"highlight_end":6}],"label":null,"suggested_replacement":"\n    }","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m: use of moved value: `config`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:59:41\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let config = Config::from_env()\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mmove occurs because `config` has type `config::Config`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     HttpServer::new(move || {\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m-------\u001b[0m \u001b[1m\u001b[94mvalue moved into closure here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .app_data(web::Data::new(config.clone()))\n   \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mvariable moved due to use in closure\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind((config.server.host.as_str(), config.server.port))?\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvalue used here after move\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value before moving it into the closure\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[92m~ \u001b[0m    HttpServer::new(\u001b[92m{\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[92m+     let value = config.clone();\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[92m~     \u001b[0mmove || {\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         App::new()\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .app_data(web::Data::new(pool.clone()))\n\u001b[1m\u001b[94m53\u001b[0m \u001b[92m~ \u001b[0m            .app_data(web::Data::new(\u001b[92mvalue\u001b[0m.clone()))\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .app_data(web::Data::new(redis_client.clone()))\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             })\n\u001b[1m\u001b[94m60\u001b[0m \u001b[92m~ \u001b[0m    }\n\u001b[1m\u001b[94m61\u001b[0m \u001b[92m~     }\u001b[0m)\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 86 previous errors; 8 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 86 previous errors; 8 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0282, E0308, E0382, E0505, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0282, E0308, E0382, E0505, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
{"$message_type":"future_incompat","future_incompat_report":[{"diagnostic":{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/cache/session.rs","byte_start":506,"byte_end":597,"line_start":20,"line_end":20,"column_start":5,"column_end":96,"is_primary":true,"text":[{"text":"    pub async fn set_session(&self, key: &str, value: &str, ttl: usize) -> Result<(), AppError> {","highlight_start":5,"highlight_end":96}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: FromRedisValue` will fail","code":null,"level":"note","spans":[{"file_name":"src/cache/session.rs","byte_start":666,"byte_end":672,"line_start":22,"line_end":22,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"        conn.set_ex(key, value, ttl).await?;","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/cache/session.rs","byte_start":672,"byte_end":672,"line_start":22,"line_end":22,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        conn.set_ex(key, value, ttl).await?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"::<_, _, ()>","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/cache/session.rs:20:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn set_session(&self, key: &str, value: &str, ttl: usize) -> Result<(), AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: FromRedisValue` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/cache/session.rs:22:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         conn.set_ex(key, value, ttl).await?;\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        conn.set_ex\u001b[92m::<_, _, ()>\u001b[0m(key, value, ttl).await?;\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}},{"diagnostic":{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/chef.rs","byte_start":221,"byte_end":382,"line_start":9,"line_end":13,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn create_chef_profile(","highlight_start":1,"highlight_end":34},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":"    user_id: web::Path<Uuid>,","highlight_start":1,"highlight_end":30},{"text":"    data: web::Json<CreateChef>,","highlight_start":1,"highlight_end":33},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/chef.rs","byte_start":1762,"byte_end":1766,"line_start":58,"line_end":58,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Created().json(chef))","highlight_start":37,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/chef.rs","byte_start":821,"byte_end":821,"line_start":29,"line_end":29,"column_start":13,"column_end":13,"is_primary":true,"text":[{"text":"    let chef = sqlx::query_as::<_, Chef>(","highlight_start":13,"highlight_end":13}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:9:1\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn create_chef_profile(\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     user_id: web::Path<Uuid>,\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     data: web::Json<CreateChef>,\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/chef.rs:58:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Created().json(chef))\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[92m^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let chef\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Chef>(\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[92m++++\u001b[0m\n\n"}},{"diagnostic":{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":231,"byte_end":376,"line_start":10,"line_end":14,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn create_menu(","highlight_start":1,"highlight_end":26},{"text":"    req: HttpRequest,","highlight_start":1,"highlight_end":22},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":"    data: web::Json<CreateMenu>,","highlight_start":1,"highlight_end":33},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1383,"byte_end":1387,"line_start":48,"line_end":48,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Created().json(menu))","highlight_start":37,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/menu.rs","byte_start":693,"byte_end":693,"line_start":26,"line_end":26,"column_start":13,"column_end":13,"is_primary":true,"text":[{"text":"    let menu = sqlx::query_as::<_, Menu>(","highlight_start":13,"highlight_end":13}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:10:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn create_menu(\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     req: HttpRequest,\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     data: web::Json<CreateMenu>,\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:48:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Created().json(menu))\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[92m^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let menu\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Menu>(\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[92m++++\u001b[0m\n\n"}},{"diagnostic":{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1393,"byte_end":1508,"line_start":51,"line_end":54,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn get_chef_menus(","highlight_start":1,"highlight_end":29},{"text":"    req: HttpRequest,","highlight_start":1,"highlight_end":22},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/menu.rs","byte_start":2002,"byte_end":2007,"line_start":72,"line_end":72,"column_start":32,"column_end":37,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Ok().json(menus))","highlight_start":32,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/menu.rs","byte_start":1797,"byte_end":1797,"line_start":65,"line_end":65,"column_start":14,"column_end":14,"is_primary":true,"text":[{"text":"    let menus = sqlx::query_as::<_, Menu>(","highlight_start":14,"highlight_end":14}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:51:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn get_chef_menus(\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     req: HttpRequest,\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/menu.rs:72:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Ok().json(menus))\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let menus\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Menu>(\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[92m++++\u001b[0m\n\n"}},{"diagnostic":{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":324,"byte_end":483,"line_start":12,"line_end":16,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn create_booking(","highlight_start":1,"highlight_end":29},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":"    chef_id: web::Path<Uuid>,","highlight_start":1,"highlight_end":30},{"text":"    data: web::Json<CreateBooking>,","highlight_start":1,"highlight_end":36},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/booking.rs","byte_start":2610,"byte_end":2617,"line_start":79,"line_end":79,"column_start":37,"column_end":44,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Created().json(booking))","highlight_start":37,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/booking.rs","byte_start":1671,"byte_end":1671,"line_start":52,"line_end":52,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    let booking = sqlx::query_as::<_, Booking>(","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:12:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn create_booking(\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     chef_id: web::Path<Uuid>,\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     data: web::Json<CreateBooking>,\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:79:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Created().json(booking))\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let booking\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Booking>(\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++\u001b[0m\n\n"}},{"diagnostic":{"$message_type":"diagnostic","message":"this function depends on never type fallback being `()`","code":{"code":"dependency_on_unit_never_type_fallback","explanation":null},"level":"error","spans":[{"file_name":"src/handlers/booking.rs","byte_start":4723,"byte_end":4871,"line_start":148,"line_end":152,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"pub async fn get_chef_bookings(","highlight_start":1,"highlight_end":32},{"text":"    req: HttpRequest,","highlight_start":1,"highlight_end":22},{"text":"    pool: web::Data<DbPool>,","highlight_start":1,"highlight_end":29},{"text":"    chef_id: web::Path<Uuid>,","highlight_start":1,"highlight_end":30},{"text":") -> Result<HttpResponse, AppError> {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"specify the types explicitly","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail","code":null,"level":"note","spans":[{"file_name":"src/handlers/booking.rs","byte_start":5443,"byte_end":5451,"line_start":172,"line_end":172,"column_start":32,"column_end":40,"is_primary":true,"text":[{"text":"    Ok(HttpResponse::Ok().json(bookings))","highlight_start":32,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `()` annotations to avoid fallback changes","code":null,"level":"help","spans":[{"file_name":"src/handlers/booking.rs","byte_start":5214,"byte_end":5214,"line_start":165,"line_end":165,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    let bookings = sqlx::query_as::<_, Booking>(","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":": ()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: this function depends on never type fallback being `()`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:148:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m148\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m pub async fn get_chef_bookings(\n\u001b[1m\u001b[94m149\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     req: HttpRequest,\n\u001b[1m\u001b[94m150\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     pool: web::Data<DbPool>,\n\u001b[1m\u001b[94m151\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     chef_id: web::Path<Uuid>,\n\u001b[1m\u001b[94m152\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m ) -> Result<HttpResponse, AppError> {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________________________________^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mwarning\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in Rust 2024 and in a future release in all editions!\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/never-type-fallback.html>\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: specify the types explicitly\n\u001b[1m\u001b[92mnote\u001b[0m: in edition 2024, the requirement `!: config::_::_serde::Serialize` will fail\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/booking.rs:172:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m172\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(HttpResponse::Ok().json(bookings))\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[92m^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[deny(dependency_on_unit_never_type_fallback)]` (part of `#[deny(rust_2024_compatibility)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: use `()` annotations to avoid fallback changes\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let bookings\u001b[92m: ()\u001b[0m = sqlx::query_as::<_, Booking>(\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m++++\u001b[0m\n\n"}}]}
